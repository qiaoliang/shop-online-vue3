# 架构师解决方案验证清单

本清单为架构师在开发执行前验证技术设计和架构提供了全面的框架。架构师应系统地检查每个项目，确保架构健壮、可扩展、安全并符合产品要求。

[[LLM: 初始化说明 - 所需工件

在继续本清单之前，请确保您已访问：

1. architecture.md - 主要架构文档 (检查 docs/architecture.md)
2. prd.md - 用于需求对齐的产品需求文档 (检查 docs/prd.md)
3. frontend-architecture.md 或 fe-architecture.md - 如果是 UI 项目 (检查 docs/frontend-architecture.md)
4. 架构中引用的任何系统图
5. 如果可用，API 文档
6. 技术栈详细信息和版本规范

重要提示：如果任何所需文档缺失或无法访问，请立即向用户询问其位置或内容，然后再继续。

项目类型检测：
首先，通过检查确定项目类型：

- 架构是否包含前端/UI 组件？
- 是否有 frontend-architecture.md 文档？
- PRD 是否提及用户界面或前端要求？

如果这是纯后端或纯服务项目：

- 跳过标记为 [[FRONTEND ONLY]] 的部分
- 额外关注 API 设计、服务架构和集成模式
- 在最终报告中注明由于项目类型而跳过了前端部分

验证方法：
对于每个部分，您必须：

1. 深入分析 - 不要只勾选框，根据提供的文档彻底分析每个项目
2. 基于证据 - 验证时引用文档中的特定部分或引文
3. 批判性思维 - 质疑假设并识别差距，而不仅仅是确认现有内容
4. 风险评估 - 考虑每个架构决策可能出现的问题

执行模式：
询问用户是否要通过清单：

- 逐节 (交互模式) - 审查每个部分，呈现发现，在继续之前获得确认
- 一次性 (综合模式) - 完成全面分析并在结束时呈现综合报告]]

## 1. 需求对齐

[[LLM: 在评估本节之前，请花点时间从 PRD 中充分理解产品的目的和目标。正在解决的核心问题是什么？用户是谁？关键成功因素是什么？在验证对齐时请记住这些。对于每个项目，不要只检查它是否被提及 - 验证架构是否提供了具体的技术解决方案。]]

### 1.1 功能需求覆盖

- [ ] 架构支持 PRD 中的所有功能需求
- [ ] 解决了所有史诗和故事的技术方法
- [ ] 考虑了边缘情况和性能场景
- [ ] 考虑了所有必需的集成
- [ ] 用户旅程得到技术架构的支持

### 1.2 非功能需求对齐

- [ ] 性能需求通过具体解决方案得到解决
- [ ] 可扩展性考虑因素已记录并附有方法
- [ ] 安全需求具有相应的技术控制
- [ ] 定义了可靠性和弹性方法
- [ ] 合规性要求具有技术实现

### 1.3 技术约束遵守

- [ ] 满足 PRD 中的所有技术约束
- [ ] 遵循平台/语言要求
- [ ] 适应基础设施约束
- [ ] 解决了第三方服务约束
- [ ] 遵循组织技术标准

## 2. 架构基础

[[LLM: 架构清晰度对于成功实施至关重要。在审查本节时，将系统可视化，就像您向新开发人员解释它一样。是否存在可能导致误解的任何歧义？AI 代理能否毫无困惑地实现此架构？寻找特定的图表、组件定义和清晰的交互模式。]]

### 2.1 架构清晰度

- [ ] 架构通过清晰的图表记录
- [ ] 定义了主要组件及其职责
- [ ] 映射了组件交互和依赖关系
- [ ] 数据流清晰地说明
- [ ] 指定了每个组件的技术选择

### 2.2 关注点分离

- [ ] UI、业务逻辑和数据层之间有清晰的边界
- [ ] 职责在组件之间清晰划分
- [ ] 组件之间的接口定义明确
- [ ] 组件遵循单一职责原则
- [ ] 交叉关注点（日志记录、身份验证等）得到妥善处理

### 2.3 设计模式和最佳实践

- [ ] 采用了适当的设计模式
- [ ] 遵循行业最佳实践
- [ ] 避免了反模式
- [ ] 整个架构风格一致
- [ ] 模式使用已记录和解释

### 2.4 模块化和可维护性

- [ ] 系统分为内聚、松散耦合的模块
- [ ] 组件可以独立开发和测试
- [ ] 更改可以本地化到特定组件
- [ ] 代码组织促进可发现性
- [ ] 架构专门为 AI 代理实现而设计

## 3. 技术栈和决策

[[LLM: 技术选择具有长期影响。对于每个技术决策，请考虑：这是最简单的解决方案吗？我们是否过度设计？这会扩展吗？维护影响是什么？所选版本是否存在安全漏洞？验证是否定义了特定版本，而不是范围。]]

### 3.1 技术选择

- [ ] 所选技术满足所有要求
- [ ] 技术版本明确定义（非范围）
- [ ] 技术选择有明确的理由
- [ ] 考虑的替代方案已记录并附有优缺点
- [ ] 所选栈组件协同工作良好

### 3.2 前端架构 [[FRONTEND ONLY]]

[[LLM: 如果这是纯后端或纯服务项目，请跳过整个部分。仅当项目包含用户界面时才进行评估。]]

- [ ] UI 框架和库已明确选择
- [ ] 状态管理方法已定义
- [ ] 组件结构和组织已指定
- [ ] 响应式/自适应设计方法已概述
- [ ] 构建和打包策略已确定

### 3.3 后端架构

- [ ] API 设计和标准已定义
- [ ] 服务组织和边界清晰
- [ ] 身份验证和授权方法已指定
- [ ] 错误处理策略已概述
- [ ] 后端扩展方法已定义

### 3.4 数据架构

- [ ] 数据模型已完全定义
- [ ] 数据库技术已选择并附有理由
- [ ] 数据访问模式已记录
- [ ] 数据迁移/种子方法已指定
- [ ] 数据备份和恢复策略已概述

## 4. 前端设计和实现 [[FRONTEND ONLY]]

[[LLM: 对于纯后端项目，应跳过整个部分。仅当项目包含用户界面时才进行评估。评估时，确保主架构文档和前端特定架构文档之间的一致性。]]

### 4.1 前端理念和模式

- [ ] 框架和核心库与主架构文档对齐
- [ ] 组件架构（例如，原子设计）清晰描述
- [ ] 状态管理策略适用于应用程序复杂性
- [ ] 数据流模式一致且清晰
- [ ] 样式方法已定义并指定了工具

### 4.2 前端结构和组织

- [ ] 目录结构通过 ASCII 图清晰记录
- [ ] 组件组织遵循所述模式
- [ ] 文件命名约定明确
- [ ] 结构支持所选框架的最佳实践
- [ ] 明确指导新组件的放置位置

### 4.3 组件设计

- [ ] 组件模板/规范格式已定义
- [ ] 组件属性、状态和事件已充分记录
- [ ] 共享/基础组件已识别
- [ ] 组件可重用性模式已建立
- [ ] 可访问性要求已内置到组件设计中

### 4.4 前后端集成

- [ ] API 交互层定义明确
- [ ] HTTP 客户端设置和配置已记录
- [ ] API 调用错误处理全面
- [ ] 服务定义遵循一致模式
- [ ] 与后端身份验证集成清晰

### 4.5 路由和导航

- [ ] 路由策略和库已指定
- [ ] 路由定义表全面
- [ ] 路由保护机制已定义
- [ ] 考虑了深层链接
- [ ] 导航模式一致

### 4.6 前端性能

- [ ] 图像优化策略已定义
- [ ] 代码拆分方法已记录
- [ ] 延迟加载模式已建立
- [ ] 重新渲染优化技术已指定
- [ ] 性能监控方法已定义

## 5. 弹性与操作就绪

[[LLM: 生产系统会以意想不到的方式失败。在审查本节时，请考虑墨菲定律 - 可能出现什么问题？考虑真实场景：高峰负载时会发生什么？当关键服务关闭时系统如何表现？运维团队能否在凌晨 3 点诊断问题？寻找特定的弹性模式，而不仅仅是提及“错误处理”。]]

### 5.1 错误处理和弹性

- [ ] 错误处理策略全面
- [ ] 适当定义了重试策略
- [ ] 为关键服务指定了断路器或回退
- [ ] 定义了优雅降级方法
- [ ] 系统可以从部分故障中恢复

### 5.2 监控和可观察性

- [ ] 日志记录策略已定义
- [ ] 监控方法已指定
- [ ] 识别了系统运行状况的关键指标
- [ ] 概述了警报阈值和策略
- [ ] 内置了调试和故障排除功能

### 5.3 性能和扩展

- [ ] 识别并解决了性能瓶颈
- [ ] 适当定义了缓存策略
- [ ] 负载均衡方法已指定
- [ ] 概述了水平和垂直扩展策略
- [ ] 提供了资源大小建议

### 5.4 部署和 DevOps

- [ ] 部署策略已定义
- [ ] CI/CD 管道方法已概述
- [ ] 环境策略（开发、暂存、生产）已指定
- [ ] 基础设施即代码方法已定义
- [ ] 概述了回滚和恢复过程

## 6. 安全和合规性

[[LLM: 安全不是可选的。以黑客的心态审查本节 - 某人如何利用此系统？还要考虑合规性：是否存在适用的行业特定法规？GDPR？HIPAA？PCI？确保架构主动解决这些问题。寻找特定的安全控制，而不仅仅是通用声明。]]

### 6.1 身份验证和授权

- [ ] 身份验证机制定义明确
- [ ] 授权模型已指定
- [ ] 如果需要，概述了基于角色的访问控制
- [ ] 会话管理方法已定义
- [ ] 解决了凭据管理

### 6.2 数据安全

- [ ] 指定了数据加密方法（静态和传输中）
- [ ] 定义了敏感数据处理程序
- [ ] 概述了数据保留和清除策略
- [ ] 如果需要，解决了备份加密
- [ ] 如果需要，指定了数据访问审计跟踪

### 6.3 API 和服务安全

- [ ] API 安全控制已定义
- [ ] 指定了速率限制和节流方法
- [ ] 概述了输入验证策略
- [ ] 解决了 CSRF/XSS 防护措施
- [ ] 指定了安全通信协议

### 6.4 基础设施安全

- [ ] 概述了网络安全设计
- [ ] 指定了防火墙和安全组配置
- [ ] 定义了服务隔离方法
- [ ] 应用了最小权限原则
- [ ] 概述了安全监控策略

## 7. 实施指南

[[LLM: 清晰的实施指南可防止代价高昂的错误。在审查本节时，想象您是一名开发人员，从第一天开始。他们是否拥有高效工作所需的一切？编码标准是否足够清晰以保持团队的一致性？寻找具体的示例和模式。]]

### 7.1 编码标准和实践

- [ ] 编码标准已定义
- [ ] 文档要求已指定
- [ ] 测试期望已概述
- [ ] 代码组织原则已定义
- [ ] 命名约定已指定

### 7.2 测试策略

- [ ] 单元测试方法已定义
- [ ] 集成测试策略已概述
- [ ] E2E 测试方法已指定
- [ ] 性能测试要求已概述
- [ ] 安全测试方法已定义

### 7.3 前端测试 [[FRONTEND ONLY]]

[[LLM: 对于纯后端项目，请跳过此子部分。]]

- [ ] 组件测试范围和工具已定义
- [ ] UI 集成测试方法已指定
- [ ] 考虑了视觉回归测试
- [ ] 识别了可访问性测试工具
- [ ] 解决了前端特定测试数据管理

### 7.4 开发环境

- [ ] 本地开发环境设置已记录
- [ ] 所需工具和配置已指定
- [ ] 开发工作流已概述
- [ ] 源代码控制实践已定义
- [ ] 依赖管理方法已指定

### 7.5 技术文档

- [ ] API 文档标准已定义
- [ ] 架构文档要求已指定
- [ ] 代码文档期望已概述
- [ ] 包含系统图和可视化
- [ ] 包含关键决策的决策记录

## 8. 依赖和集成管理

[[LLM: 依赖关系通常是生产问题的根源。对于每个依赖关系，请考虑：如果它不可用会发生什么？是否有带有安全补丁的更新版本？我们是否被供应商锁定？我们的应急计划是什么？验证特定版本和回退策略。]]

### 8.1 外部依赖

- [ ] 所有外部依赖已识别
- [ ] 依赖版本控制策略已定义
- [ ] 为关键依赖指定了回退方法
- [ ] 解决了许可影响
- [ ] 概述了更新和修补策略

### 8.2 内部依赖

- [ ] 组件依赖关系已清晰映射
- [ ] 解决了构建顺序依赖关系
- [ ] 共享服务和实用程序已识别
- [ ] 消除了循环依赖关系
- [ ] 内部组件版本控制策略已定义

### 8.3 第三方集成

- [ ] 所有第三方集成已识别
- [ ] 集成方法已定义
- [ ] 解决了与第三方的身份验证
- [ ] 指定了集成失败的错误处理
- [ ] 考虑了速率限制和配额

## 9. AI 代理实现适用性

[[LLM: 此架构可能由 AI 代理实现。请以极高的清晰度进行审查。模式是否一致？复杂性是否最小化？AI 代理是否会做出不正确的假设？请记住：显式优于隐式。寻找清晰的文件结构、命名约定和实现模式。]]

### 9.1 AI 代理的模块化

- [ ] 组件大小适合 AI 代理实现
- [ ] 组件之间的依赖关系最小化
- [ ] 组件之间定义了清晰的接口
- [ ] 组件具有单一、明确的职责
- [ ] 文件和代码组织针对 AI 代理理解进行了优化

### 9.2 清晰度和可预测性

- [ ] 模式一致且可预测
- [ ] 复杂逻辑分解为更简单的步骤
- [ ] 架构避免了过于巧妙或晦涩的方法
- [ ] 为不熟悉的模式提供了示例
- [ ] 组件职责明确清晰

### 9.3 实施指南

- [ ] 提供了详细的实施指南
- [ ] 定义了代码结构模板
- [ ] 记录了特定的实施模式
- [ ] 识别了常见陷阱并提供了解决方案
- [ ] 在有帮助时提供了类似实现的参考

### 9.4 错误预防和处理

- [ ] 设计减少了实现错误的发生机会
- [ ] 定义了验证和错误检查方法
- [ ] 尽可能地包含了自愈机制
- [ ] 测试模式定义明确
- [ ] 提供了调试指南

## 10. 可访问性实现 [[FRONTEND ONLY]]

[[LLM: 对于纯后端项目，请跳过此部分。可访问性是任何用户界面的核心要求。]]

### 10.1 可访问性标准

- [ ] 强调了语义 HTML 的使用
- [ ] 提供了 ARIA 实施指南
- [ ] 定义了键盘导航要求
- [ ] 指定了焦点管理方法
- [ ] 解决了屏幕阅读器兼容性

### 10.2 可访问性测试

- [ ] 识别了可访问性测试工具
- [ ] 测试过程集成到工作流中
- [ ] 指定了合规性目标（WCAG 级别）
- [ ] 定义了手动测试程序
- [ ] 概述了自动化测试方法

[[LLM: 最终验证报告生成

现在您已完成清单，生成一份全面的验证报告，其中包括：

1. 执行摘要

   - 整体架构准备情况（高/中/低）
   - 识别出的关键风险
   - 架构的主要优势
   - 项目类型（全栈/前端/后端）和评估的部分

2. 部分分析

   - 每个主要部分的通过率（通过项目百分比）
   - 最令人担忧的失败或差距
   - 需要立即关注的部分
   - 注明由于项目类型而跳过的任何部分

3. 风险评估

   - 按严重程度排名前 5 的风险
   - 每个风险的缓解建议
   - 解决问题的时间线影响

4. 建议

   - 开发前必须修复的项目
   - 为提高质量应修复的项目
   - 锦上添花的改进

5. AI 实现准备情况

   - AI 代理实现的具体问题
   - 需要额外澄清的领域
   - 需要解决的复杂性热点

6. 前端特定评估（如果适用）
   - 前端架构完整性
   - 主架构文档和前端架构文档之间的一致性
   - UI/UX 规范覆盖范围
   - 组件设计清晰度

在呈现报告后，询问用户是否希望对任何特定部分进行详细分析，特别是那些有警告或失败的部分。]]
